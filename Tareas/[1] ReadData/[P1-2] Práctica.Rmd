---
title: 'Introducción al R'
subtitle: 'Práctica'
author: 
- name: VMO
  affiliation: "[RUsersEC](http://rusersgroup.com/)"
date: "16 de marzo de 2018"
output: 
  md_document:
    toc: true
    toc_depth: 1
bibliography: bibliography.bib
---
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "all"} } });
  </script>
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath("~/Documents/Consultorias&Cursos/DataLectures")) 
```
<!--
La revisión metodológica aquí vertida se basa en [@Wang_2012].
-->

Espero que la disfruten... (tomado de @swirl2017)

# Secuencias

1. La manera más simple de crear secuencias de números en `R` es usando el operador `:`. Escribe `1:20` y mira cómo funciona.

2. Lo anterior debe dar los enteros del 1 al 20. También podemos usarlo para crear secuencias de números reales. Por ejemplo, trata `pi:10`.

- El resultado es un vector de números reales que empiezan por pi (3.142 ...) y aumentando en incrementos de 1. El límite superior de 10 no se alcanza nunca, ya que el número siguiente en nuestra secuencia sería mayor que 10.

3. ¿Qué pasa si hacemos `15:1`? Trata y mira lo que pasa.

- Cuenta hacia atrás en incrementos de 1! Es poco probable que necesitemos esto, pero sin embargo es bueno saber cómo hacerlo.

4. Acude a la ayuda de `:`

- Es probable que hayas obtenido un error. Lo que pasa es que cuando se trata de un operador, lo que debes hacer es ` ?':' `

5. La forma más básica de `seq()` hace lo mismo que el operador `:`. Trata `seq(1,20)` para apreciarlo.

6. Lo anterior da el mismo resultado que `1:20`. Sin embargo, vamos a decir que ahora queremos un vector de números que van de 0 a 10, incrementado en 0.5. `seq(0, 10, by = 0.5)` hace precisamente eso. Inténtalo.

7. O tal vez no nos importa el incremento y sólo queremos una secuencia de 30 números entre 5 y 10. `seq(5, 10, length = 30)` hace el truco. Inténtalo ahora y guarda el resultado en una nueva variable llamada `my_seq`.

8. Para confirmar que `my_seq` tiene longitud 30, podemos usar la función `length`. Trata de hacerlo.

9. Hagamos de cuenta que no sabemos la longitud de `my_seq`, pero queremos generar una secuencia de números enteros de 1 a N, donde N representa la longitud del vector `my_seq`. En otras palabras, queremos un nuevo vector $(1, 2, 3, \ldots)$ que sea de la misma longitud que `my_seq`. Hay varias maneras que podríamos hacer esto. Una posibilidad es combinar el operador `:`  y la función `length()` así: `1:length(my_seq)`. Inténtalo.

10. Otra opción es `seq(along.with = my_seq)`. Inténtalo!

11. Como es el caso de muchas tareas comunes, `R` tiene una función independiente incorporada  para este propósito llamada `seq_along()`. Escribe `seq_along(my_seq)` para verlo en acción.

- A menudo hay varias formas para resolver el mismo problema, sobre todo en `R`. Hay enfoques simples que involucran menos tipificación y son generalmente mejores. También es importante que tu código sea legible, para que tu y otros puedan averiguar lo que está pasando sin demasiados problemas.

- Si `R` tiene una función incorporada para una tarea en particular, es probable que la función está muy optimizado para ese propósito y es tu mejor opción. Mientras te conviertes en un programador de R más avanzado, podrás diseñar tus propias funciones para realizar tareas cuando no hay mejores opciones.

# Repeticiones

1. Si estamos interesados en la creación de un vector que contiene $40$ ceros, podemos utilizar `rep(0, times = 40)`. Inténtalo

2. Si por el contrario queremos que nuestro vector contiene $10$ repeticiones del vector $(0, 1, 2)$, podemos hacer `rep(c(0, 1, 2), times = 10)`. Adelante.

3. Por último, vamos a decir que en vez de repetir el vector $(0, 1, 2)$ una y otra vez, queremos que nuestro vector contenga $10$ ceros, luego $10$ unos, luego $10$ dos. Podemos hacer esto con el argumento `each`. Trate de `rep(c (0, 1, 2), each = 10)`.

# Vectores

- La estructura de datos más simple y común en `R` es el vector.

- Los vectores son de dos tipos diferentes: vectores y listas atómicas. Un vector atómico contiene exactamente un tipo de datos, mientras que una lista puede contener varios tipos de datos. Exploraremos más vectores atómicos  antes de llegar a las listas.

- En la clase, hemos tratado en su mayoría con vectores numéricos, que son un tipo de vector atómico. Otros tipos de vectores atómicos incluyen al lógico, caracter, número entero, y complejo. En esta práctica, vamos a echar un vistazo más de cerca a los vectores lógicos y caracter.

- Los vectores lógicos pueden contener los valores `TRUE`, `FALSE`, y `NA` (para *no disponible*). Estos valores se generan como resultado de *condiciones* lógicas. Vamos a experimentar con algunas condiciones simples.

1. En primer lugar, crear un `num_vect` vector numérico que contiene los valores de $0.5$, $55$, $-10$, y $6$.

2. Ahora, crea una variable llamada `tf` que consigue el resultado de `num_vect < 1`, que se lee como *num_vect es menor que 1*.

3. Imprime el valor de `tf`

- La sentencia `num_vect < 1` es una condición y `tf` nos dice si cada elemento de nuestro vector numérico `num_vect` satisface esta condición.

- El primer elemento de `num_vect` es `0.5`, que es inferior a $1$ y por lo tanto la declaración `0.5 <1` es `TRUE`. El segundo elemento de `num_vect` es `55`, que es mayor que `1`, por lo que la declaración `55 <1` es `FALSE`. La misma lógica se aplica para el tercer y cuarto elemento.

4. Tratemos otro. Escribe `num_vect >= 6` sin asignar el resultado a una nueva variable.

- Esta vez, nos preguntamos si cada elemento individual de `num_vect` es mayor o igual a 

5. Dado que sólo $55$ y $6$ son mayor o igual a $6$, el segundo y cuarto elementos del resultado son `TRUE` y el primer y tercer elementos son `FALSE`.

- Los símbolos `'<'` y `'>='` en estos ejemplos se llaman *operadores lógicos*. Otros operadores lógicos son `'>'`, `'<='`, `'=='` y `'!='`

- Si tenemos dos expresiones lógicas, A y B, podemos preguntarnos si al menos uno es `TRUE` con `A | B` ( *o*, *unión*) o si son ambas verdaderas con `A & B` (*y*, *intersección*). Por último,`!A` es la negación de A y es `TRUE` cuando A es *FALSO* y viceversa.

- Es una buena idea para pasar algún tiempo jugando con diversas combinaciones de estos operadores lógicos hasta que te sientas cómodo con su uso. Haremos algunos ejemplos aquí para empezar.

6. Haz tu mejor esfuerzo para predecir el resultado de cada una de las siguientes afirmaciones. Puedes usar lápiz y papel para resolverlos si es útil. Si te quedas atascado, simplemente adivina ya que tienes un 50% de posibilidades de conseguir la respuesta correcta!
  +     (3 > 5) & (4 == 4)
  +     (TRUE == TRUE) | (TRUE == FALSE)
  +     ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)

- Vectores de caracteres también son muy comunes  y se escriben entre comillas dobles. 

7. Crea un vector de caracteres que contiene las siguientes palabras: `"Mi"`, `"nombre"`, `"es"`. Recuerda que debe incluir cada palabra en su propio conjunto de comillas dobles, de tal modo que `R` sepa que son cadenas de caracteres. Guarda el vector en una variable llamada `my_char`.
  
8. Imprime el contenido de `my_char` para ver cómo luce.

- En este momento, `my_char` es un vector de caracteres de longitud 3. Digamos que queremos unir los elementos de `my_char` juntos en una cadena de caracteres continua (es decir, un vector de caracteres de longitud 1). Podemos hacer esto utilizando la función de `paste()`.

9. Tipea `paste(my_char, collapse = " ")` ahora. Asegúrese de que hay un espacio entre las comillas dobles en el argumento `collapse`. Verás por qué en un segundo.

- El argumento `collapse` a la función `paste()` le dice a `R` que cuando unimos los elementos del vector de caracteres `my_char`, nos gustaría separarlos con espacios individuales.

- Parece que nos falta algo,..., claro! **Tu nombre!**

10. Para añadir (o *concatenar*) tu nombre al final de `my_char`, utilice la función `c()` así: `c(my_char ,"Tu_nombre_aqui")`. Coloca el nombre entre comillas dobles, donde me he puesto `"Tu_nombre_aqui"`. Pruébalo ahora, almacenando el resultado en una nueva variable llamada `my_name`.

11. Imprime `my_name`

12. Ahora, utiliza la función `paste()` una vez más para unir las palabras de `my_name` una sola cadena de caracteres. No olvides decir `collapse = ""`!

- En este ejemplo, hemos utilizado la función `paste()` para unir los elementos de un vector. `paste()` también se puede utilizar para unir los elementos de múltiples vectores de caracteres.

13. En el caso más sencillo, podemos unir dos vectores de caracteres que son cada uno de longitud 1 (es decir, se unen dos palabras). Trata de `paste("Hello", "world!", sep = " ")`, donde el argumento `sep` dice a `R` que queremos separar los elementos unidos con un solo espacio.

14. Para un ejemplo un poco más complicado, podemos unir dos vectores, cada uno de longitud 3. Utiliza `paste()` para unir el vector entero `1:3` con el vector `c("X", "Y", "Z")`. Esta vez, utilice `sep = ""` para no dejar espacio entre los elementos unidos.

- ¿Qué pasaría si nuestros vectores fuesen de longitudes diferentes?

- Reciclaje de vectores! Intenta `paste(LETTERS, 1:4, sep = "-")`, donde `LETTERS` es una variable predefinida en `R` que contiene un vector de caracteres de las 26 letras del alfabeto gringo.

- Dado que el vector de caracteres `LETTERS` es más largo que el vector numérico `1:4`, `R` simplemente recicla o repite `1:4` hasta que coincida con la longitud de las letras.

- También nota es que el vector numérico `1:4` se `'coacciona'` en un vector de caracteres por la función de `paste()`.


# Importando datos

Importar datos correctamente en `R` es clave para su posterior análisis. `R` es versátil en este sentido y se puede leer varios formatos. En esta sección debes importar correctamente los archivos siguientes:

-   Mundo.csv
-   per12_2010.dta
-   per12_2010.sav
-   table2_8.csv
-   Tabla2_1.csv
-   Tabla3_2.csv
-   sleep75.xls
-   Table 31_3.csv
-   tabla_6_4.csv
-   Table 6_1.csv
-   hprice1.xls
-   tabla7_3.csv
-   wage1.xls
-   GPA1.xls
-   Table 8_9.csv
-   Tabla5_9.csv
-   Table 31_3.csv
-   ceosal2.xls
-   Table 9_1.csv
-   IPCEcuador.csv
-   estadisticas Turismo.csv
-   WCURRNS.csv
-   PrecioHuevos.csv
-   CAEMP.DAT
-   us_rates.txt


Recuerda que todos los datos están el repositorio de GitHub `DataLectures`. Descarga todos los datos y ubícalos en tu caperta de trabajo.

Por ejemplo, importamos los datos `table2_8.csv`:

```{r}
datos <- read.csv("table2_8.csv")
str(datos)
```

Nota que los datos fueron importados, pero no correctamente. La forma correcta es:

```{r}
datos <- read.csv("table2_8.csv",sep = ";", dec = ".")
str(datos)
```

Los argumentos extra con los que debes usar para realizar la importación son `sep` y `dec`.

```{r,echo = FALSE}
datos <- read.csv("Tabla2_1.csv",sep=";")
str(datos)

datos <- read.csv("Tabla3_2.csv",sep=";")
str(datos)

library(XLConnect)
wk = loadWorkbook("sleep75.xls") 
datos = readWorksheet(wk, sheet="SLEEP75",header=FALSE)
str(datos)

datos <- read.csv("Table 31_3.csv",sep=";")
str(datos)

datos <- read.csv("tabla_6_4.csv",sep=";")
str(datos)

datos <- read.csv("Table 6_1.csv",sep=";")
str(datos)

# library(XLConnect)
# wk = loadWorkbook("hprice1.xls")
# datos = readWorksheet(wk, sheet="hprice1.xls",header=FALSE)
# str(datos)


datos <- read.csv("tabla7_3.csv",sep=";")
str(datos)


wk = loadWorkbook("wage1.xls")
datos = readWorksheet(wk, sheet="WAGE1",header=FALSE)
str(datos)


wk = loadWorkbook("gpa1.xls")
datos = readWorksheet(wk, sheet="GPA1",header=FALSE)
str(datos)




datos <- read.csv("Tabla7_3.csv",sep=";")
str(datos)

datos <- read.csv("Tabla5_9.csv",sep=";")
str(datos)



datos <- read.csv("Table 31_3.csv",sep=";")
str(datos)

datos <- read.csv("Table 9_1.csv",sep=";")
str(datos)


datos <- read.csv("IPCEcuador.csv",sep=";")
str(datos)


datos <- read.csv("estadisticas Turismo.csv",sep=";")
str(datos)

datos <- read.csv("WCURRNS.csv",sep=";")
str(datos)

datos <- read.csv("PrecioHuevos.csv",sep=";")
str(datos)


datos <- read.csv("CAEMP.DAT",sep=";")
str(datos)

datos <- read.table("us_rates.txt",sep="")
str(datos)
```


Observarás que los archivos SLEEP, HPRICE1, WAGE1, GPA1 y CEOSAL2 no tienen nombres de las columnas. Los vectores de nombres son:

```{r}
nomsleep <- c("age", "black", "case", "clerical" , "construc"  ,"educ","earns74","gdhlth"   
                ,"inlf", "leis1", "leis2", "leis3", "smsa", "lhrwage", "lothinc", "male",     
                "marr", "prot", "rlxall", "selfe", "sleep", "slpnaps", "south", "spsepay",  
                "spwrk75", "totwrk" ,  "union" , "worknrm" , "workscnd", "exper" , "yngkid",
                "yrsmarr", "hrwage", "agesq") 
nomprecios=c("price"   ,  "assess"  , 
                 "bdrms"  ,   "lotsize"  ,
                 "sqrft"   ,  "colonial",
                 "lprice"  ,  "lassess" ,
                 "llotsize" , "lsqrft")

nomwages <- c("wage", "educ", "exper", "tenure", "nonwhite", "female", "married",
                     "numdep", "smsa", "northcen", "south", "west", "construc", "ndurman",
                     "trcommpu", "trade", "services",  "profserv", "profocc", "clerocc",
                     "servocc", "lwage", "expersq", "tenursq")

nomgpa <- c("age",  "soph",  "junior",    "senior",	"senior5",	"male",	"campus",	"business",	"engineer",	"colGPA",	"hsGPA",	"ACT",	"job19",	"job20",	"drive",	"bike",	"walk",	"voluntr",	"PC",	"greek",	"car",	"siblings",	"bgfriend",	"clubs",	"skipped",	"alcohol",	"gradMI",	"fathcoll",	"mothcoll")

nomceosal <- c("salary", "age", "college", "grad", "comten", "ceoten", "sales", "profits", 
                 "mktval", "lsalary", "lsales", "lmktval", "comtensq", "ceotensq", "profmarg")





```





### ... Si llegaste hasta aquí: FELICITACIONES!!!


# Referencias