-   [Secuencias](#secuencias)
-   [Repeticiones](#repeticiones)
-   [Vectores](#vectores)
-   [Importando datos](#importando-datos)
-   [Referencias](#referencias)

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "all"} } });
  </script>

------------------------------------------------------------------------

<!--
La revisión metodológica aquí vertida se basa en [@Wang_2012].
-->
Espero que la disfruten... (tomado de Kross et al. (2017))

Secuencias
==========

1.  La manera más simple de crear secuencias de números en `R` es usando
    el operador `:`. Escribe `1:20` y mira cómo funciona.

2.  Lo anterior debe dar los enteros del 1 al 20. También podemos usarlo
    para crear secuencias de números reales. Por ejemplo, trata `pi:10`.

-   El resultado es un vector de números reales que empiezan por pi
    (3.142 ...) y aumentando en incrementos de 1. El límite superior de
    10 no se alcanza nunca, ya que el número siguiente en nuestra
    secuencia sería mayor que 10.

1.  ¿Qué pasa si hacemos `15:1`? Trata y mira lo que pasa.

-   Cuenta hacia atrás en incrementos de 1! Es poco probable que
    necesitemos esto, pero sin embargo es bueno saber cómo hacerlo.

1.  Acude a la ayuda de `:`

-   Es probable que hayas obtenido un error. Lo que pasa es que cuando
    se trata de un operador, lo que debes hacer es `?':'`

1.  La forma más básica de `seq()` hace lo mismo que el operador `:`.
    Trata `seq(1,20)` para apreciarlo.

2.  Lo anterior da el mismo resultado que `1:20`. Sin embargo, vamos a
    decir que ahora queremos un vector de números que van de 0 a 10,
    incrementado en 0.5. `seq(0, 10, by = 0.5)` hace precisamente eso.
    Inténtalo.

3.  O tal vez no nos importa el incremento y sólo queremos una secuencia
    de 30 números entre 5 y 10. `seq(5, 10, length = 30)` hace el truco.
    Inténtalo ahora y guarda el resultado en una nueva variable llamada
    `my_seq`.

4.  Para confirmar que `my_seq` tiene longitud 30, podemos usar la
    función `length`. Trata de hacerlo.

5.  Hagamos de cuenta que no sabemos la longitud de `my_seq`, pero
    queremos generar una secuencia de números enteros de 1 a N, donde N
    representa la longitud del vector `my_seq`. En otras palabras,
    queremos un nuevo vector (1, 2, 3, …) que sea de la misma longitud
    que `my_seq`. Hay varias maneras que podríamos hacer esto. Una
    posibilidad es combinar el operador `:` y la función `length()` así:
    `1:length(my_seq)`. Inténtalo.

6.  Otra opción es `seq(along.with = my_seq)`. Inténtalo!

7.  Como es el caso de muchas tareas comunes, `R` tiene una función
    independiente incorporada para este propósito llamada `seq_along()`.
    Escribe `seq_along(my_seq)` para verlo en acción.

-   A menudo hay varias formas para resolver el mismo problema, sobre
    todo en `R`. Hay enfoques simples que involucran menos tipificación
    y son generalmente mejores. También es importante que tu código sea
    legible, para que tu y otros puedan averiguar lo que está pasando
    sin demasiados problemas.

-   Si `R` tiene una función incorporada para una tarea en particular,
    es probable que la función está muy optimizado para ese propósito y
    es tu mejor opción. Mientras te conviertes en un programador de R
    más avanzado, podrás diseñar tus propias funciones para realizar
    tareas cuando no hay mejores opciones.

Repeticiones
============

1.  Si estamos interesados en la creación de un vector que contiene 40
    ceros, podemos utilizar `rep(0, times = 40)`. Inténtalo

2.  Si por el contrario queremos que nuestro vector contiene 10
    repeticiones del vector (0, 1, 2), podemos hacer
    `rep(c(0, 1, 2), times = 10)`. Adelante.

3.  Por último, vamos a decir que en vez de repetir el vector (0, 1, 2)
    una y otra vez, queremos que nuestro vector contenga 10 ceros, luego
    10 unos, luego 10 dos. Podemos hacer esto con el argumento `each`.
    Trate de `rep(c (0, 1, 2), each = 10)`.

Vectores
========

-   La estructura de datos más simple y común en `R` es el vector.

-   Los vectores son de dos tipos diferentes: vectores y listas
    atómicas. Un vector atómico contiene exactamente un tipo de datos,
    mientras que una lista puede contener varios tipos de datos.
    Exploraremos más vectores atómicos antes de llegar a las listas.

-   En la clase, hemos tratado en su mayoría con vectores numéricos, que
    son un tipo de vector atómico. Otros tipos de vectores atómicos
    incluyen al lógico, caracter, número entero, y complejo. En esta
    práctica, vamos a echar un vistazo más de cerca a los vectores
    lógicos y caracter.

-   Los vectores lógicos pueden contener los valores `TRUE`, `FALSE`, y
    `NA` (para *no disponible*). Estos valores se generan como resultado
    de *condiciones* lógicas. Vamos a experimentar con algunas
    condiciones simples.

1.  En primer lugar, crear un `num_vect` vector numérico que contiene
    los valores de 0.5, 55, −10, y 6.

2.  Ahora, crea una variable llamada `tf` que consigue el resultado de
    `num_vect < 1`, que se lee como *num\_vect es menor que 1*.

3.  Imprime el valor de `tf`

-   La sentencia `num_vect < 1` es una condición y `tf` nos dice si cada
    elemento de nuestro vector numérico `num_vect` satisface esta
    condición.

-   El primer elemento de `num_vect` es `0.5`, que es inferior a 1 y por
    lo tanto la declaración `0.5 <1` es `TRUE`. El segundo elemento de
    `num_vect` es `55`, que es mayor que `1`, por lo que la declaración
    `55 <1` es `FALSE`. La misma lógica se aplica para el tercer y
    cuarto elemento.

1.  Tratemos otro. Escribe `num_vect >= 6` sin asignar el resultado a
    una nueva variable.

-   Esta vez, nos preguntamos si cada elemento individual de `num_vect`
    es mayor o igual a

1.  Dado que sólo 55 y 6 son mayor o igual a 6, el segundo y cuarto
    elementos del resultado son `TRUE` y el primer y tercer elementos
    son `FALSE`.

-   Los símbolos `'<'` y `'>='` en estos ejemplos se llaman *operadores
    lógicos*. Otros operadores lógicos son `'>'`, `'<='`, `'=='` y
    `'!='`

-   Si tenemos dos expresiones lógicas, A y B, podemos preguntarnos si
    al menos uno es `TRUE` con `A | B` ( *o*, *unión*) o si son ambas
    verdaderas con `A & B` (*y*, *intersección*). Por último,`!A` es la
    negación de A y es `TRUE` cuando A es *FALSO* y viceversa.

-   Es una buena idea para pasar algún tiempo jugando con diversas
    combinaciones de estos operadores lógicos hasta que te sientas
    cómodo con su uso. Haremos algunos ejemplos aquí para empezar.

1.  Haz tu mejor esfuerzo para predecir el resultado de cada una de las
    siguientes afirmaciones. Puedes usar lápiz y papel para resolverlos
    si es útil. Si te quedas atascado, simplemente adivina ya que tienes
    un 50% de posibilidades de conseguir la respuesta correcta!

-   (3 > 5) & (4 == 4)

-   (TRUE == TRUE) | (TRUE == FALSE)

-   ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)

-   Vectores de caracteres también son muy comunes y se escriben entre
    comillas dobles.

1.  Crea un vector de caracteres que contiene las siguientes palabras:
    `"Mi"`, `"nombre"`, `"es"`. Recuerda que debe incluir cada palabra
    en su propio conjunto de comillas dobles, de tal modo que `R` sepa
    que son cadenas de caracteres. Guarda el vector en una variable
    llamada `my_char`.

2.  Imprime el contenido de `my_char` para ver cómo luce.

-   En este momento, `my_char` es un vector de caracteres de longitud 3.
    Digamos que queremos unir los elementos de `my_char` juntos en una
    cadena de caracteres continua (es decir, un vector de caracteres de
    longitud 1). Podemos hacer esto utilizando la función de `paste()`.

1.  Tipea `paste(my_char, collapse = " ")` ahora. Asegúrese de que hay
    un espacio entre las comillas dobles en el argumento `collapse`.
    Verás por qué en un segundo.

-   El argumento `collapse` a la función `paste()` le dice a `R` que
    cuando unimos los elementos del vector de caracteres `my_char`, nos
    gustaría separarlos con espacios individuales.

-   Parece que nos falta algo,..., claro! **Tu nombre!**

1.  Para añadir (o *concatenar*) tu nombre al final de `my_char`,
    utilice la función `c()` así: `c(my_char ,"Tu_nombre_aqui")`. Coloca
    el nombre entre comillas dobles, donde me he puesto
    `"Tu_nombre_aqui"`. Pruébalo ahora, almacenando el resultado en una
    nueva variable llamada `my_name`.

2.  Imprime `my_name`

3.  Ahora, utiliza la función `paste()` una vez más para unir las
    palabras de `my_name` una sola cadena de caracteres. No olvides
    decir `collapse = ""`!

-   En este ejemplo, hemos utilizado la función `paste()` para unir los
    elementos de un vector. `paste()` también se puede utilizar para
    unir los elementos de múltiples vectores de caracteres.

1.  En el caso más sencillo, podemos unir dos vectores de caracteres que
    son cada uno de longitud 1 (es decir, se unen dos palabras). Trata
    de `paste("Hello", "world!", sep = " ")`, donde el argumento `sep`
    dice a `R` que queremos separar los elementos unidos con un solo
    espacio.

2.  Para un ejemplo un poco más complicado, podemos unir dos vectores,
    cada uno de longitud 3. Utiliza `paste()` para unir el vector entero
    `1:3` con el vector `c("X", "Y", "Z")`. Esta vez, utilice `sep = ""`
    para no dejar espacio entre los elementos unidos.

-   ¿Qué pasaría si nuestros vectores fuesen de longitudes diferentes?

-   Reciclaje de vectores! Intenta `paste(LETTERS, 1:4, sep = "-")`,
    donde `LETTERS` es una variable predefinida en `R` que contiene un
    vector de caracteres de las 26 letras del alfabeto gringo.

-   Dado que el vector de caracteres `LETTERS` es más largo que el
    vector numérico `1:4`, `R` simplemente recicla o repite `1:4` hasta
    que coincida con la longitud de las letras.

-   También nota es que el vector numérico `1:4` se `'coacciona'` en un
    vector de caracteres por la función de `paste()`.

Importando datos
================

Importar datos correctamente en `R` es clave para su posterior análisis.
`R` es versátil en este sentido y se puede leer varios formatos. En esta
sección debes importar correctamente los archivos siguientes:

-   Mundo.csv
-   per12\_2010.dta
-   per12\_2010.sav
-   table2\_8.csv
-   Tabla2\_1.csv
-   Tabla3\_2.csv
-   sleep75.xls
-   Table 31\_3.csv
-   tabla\_6\_4.csv
-   Table 6\_1.csv
-   hprice1.xls
-   tabla7\_3.csv
-   wage1.xls
-   GPA1.xls
-   Table 8\_9.csv
-   Tabla5\_9.csv
-   Table 31\_3.csv
-   ceosal2.xls
-   Table 9\_1.csv
-   IPCEcuador.csv
-   estadisticas Turismo.csv
-   WCURRNS.csv
-   PrecioHuevos.csv
-   CAEMP.DAT
-   us\_rates.txt

Recuerda que todos los datos están el repositorio de GitHub
`DataLectures`. Descarga todos los datos y ubícalos en tu caperta de
trabajo.

Por ejemplo, importamos los datos `table2_8.csv`:

    datos <- read.csv("table2_8.csv")
    str(datos)

    ## 'data.frame':    55 obs. of  1 variable:
    ##  $ obs.FOODEXP.TOTALEXP: Factor w/ 55 levels "1;217;382","10;345;516",..: 1 12 23 34 45 52 53 54 55 2 ...

Nota que los datos fueron importados, pero no correctamente. La forma
correcta es:

    datos <- read.csv("table2_8.csv",sep = ";", dec = ".")
    str(datos)

    ## 'data.frame':    55 obs. of  3 variables:
    ##  $ obs     : int  1 2 3 4 5 6 7 8 9 10 ...
    ##  $ FOODEXP : int  217 196 303 270 325 260 300 325 336 345 ...
    ##  $ TOTALEXP: int  382 388 391 415 456 460 472 478 494 516 ...

Los argumentos extra con los que debes usar para realizar la importación
son `sep` y `dec`.

    ## 'data.frame':    55 obs. of  2 variables:
    ##  $ X: int  80 80 80 80 80 100 100 100 100 100 ...
    ##  $ Y: int  55 60 65 70 75 65 70 74 80 85 ...

    ## 'data.frame':    10 obs. of  2 variables:
    ##  $ Y: int  70 65 90 95 110 115 120 140 155 150
    ##  $ X: int  80 100 120 140 160 180 200 220 240 260

    ## Loading required package: XLConnectJars

    ## XLConnect 0.2-13 by Mirai Solutions GmbH [aut],
    ##   Martin Studer [cre],
    ##   The Apache Software Foundation [ctb, cph] (Apache POI),
    ##   Graph Builder [ctb, cph] (Curvesapi Java library)

    ## http://www.mirai-solutions.com ,
    ## http://miraisolutions.wordpress.com

    ## 'data.frame':    706 obs. of  34 variables:
    ##  $ Col1 : num  32 31 44 30 64 41 35 47 32 30 ...
    ##  $ Col2 : num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col3 : num  1 2 3 4 5 6 7 8 9 10 ...
    ##  $ Col4 : num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col5 : num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col6 : num  12 14 17 12 14 12 12 13 17 15 ...
    ##  $ Col7 : num  0 9500 42500 42500 2500 ...
    ##  $ Col8 : num  0 1 1 1 1 1 1 1 1 1 ...
    ##  $ Col9 : num  1 1 1 1 1 1 1 1 1 1 ...
    ##  $ Col10: num  3529 2140 4595 3211 4052 ...
    ##  $ Col11: num  3479 2140 4505 3211 4007 ...
    ##  $ Col12: num  3479 2140 4227 3211 4007 ...
    ##  $ Col13: num  0 0 1 0 0 0 0 1 0 1 ...
    ##  $ Col14: chr  "1,955861" "0,357674" "3,021887" "2,263844" ...
    ##  $ Col15: num  10.08 0 0 0 9.33 ...
    ##  $ Col16: num  1 1 1 0 1 1 1 1 1 1 ...
    ##  $ Col17: num  1 0 1 1 1 1 1 1 1 1 ...
    ##  $ Col18: num  1 1 0 1 1 1 1 1 0 0 ...
    ##  $ Col19: num  3163 2920 3038 3083 3493 ...
    ##  $ Col20: num  0 1 1 1 0 0 0 1 0 1 ...
    ##  $ Col21: num  3113 2920 2670 3083 3448 ...
    ##  $ Col22: num  3163 2920 2760 3083 3493 ...
    ##  $ Col23: num  0 1 0 0 0 0 0 0 0 0 ...
    ##  $ Col24: num  0 0 20000 5000 2400 0 12000 0 0 6000 ...
    ##  $ Col25: num  0 0 1 1 1 0 1 0 0 1 ...
    ##  $ Col26: num  3438 5020 2815 3786 2580 ...
    ##  $ Col27: num  0 0 0 0 0 0 0 0 1 0 ...
    ##  $ Col28: num  3438 5020 2815 3786 2580 ...
    ##  $ Col29: num  0 0 0 0 0 ...
    ##  $ Col30: num  14 11 21 12 44 23 17 28 9 9 ...
    ##  $ Col31: num  0 0 0 0 0 0 1 0 0 0 ...
    ##  $ Col32: num  13 0 0 12 33 23 0 24 11 7 ...
    ##  $ Col33: chr  "7,070004" "1,429999" "20,53" "9,619998" ...
    ##  $ Col34: num  1024 961 1936 900 4096 ...

    ## 'data.frame':    34 obs. of  4 variables:
    ##  $ Country   : Factor w/ 34 levels "Argentina","Australia",..: 1 2 3 4 5 6 7 8 9 10 ...
    ##  $ Cellphone : num  17.8 72 79.3 26.4 46.6 ...
    ##  $ PCs       : num  8.2 60.18 31.81 7.48 5.19 ...
    ##  $ Pcapincome: int  11410 28780 28920 7510 7400 30040 4980 6410 15600 3940 ...

    ## 'data.frame':    64 obs. of  4 variables:
    ##  $ CM  : int  128 204 202 197 96 209 170 240 241 55 ...
    ##  $ FLR : int  37 22 16 65 76 26 45 29 11 55 ...
    ##  $ PGNP: int  1870 130 310 570 2050 200 670 300 120 290 ...
    ##  $ TFR : num  6.66 6.15 7 6.25 3.81 6.44 6.19 5.89 5.89 2.36 ...

    ## 'data.frame':    240 obs. of  2 variables:
    ##  $ Y: num  6.08 -0.924 -3.286 5.212 -16.164 ...
    ##  $ X: num  7.263 6.34 -9.285 0.793 -2.902 ...

    ## 'data.frame':    15 obs. of  4 variables:
    ##  $ Year: int  1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 ...
    ##  $ Y   : num  16608 17511 20171 20933 20406 ...
    ##  $ X2  : num  276 274 270 267 268 ...
    ##  $ X3  : num  17804 18097 18272 19167 19648 ...

    ## 'data.frame':    526 obs. of  24 variables:
    ##  $ Col1 : num  3.1 3.24 3 6 5.3 ...
    ##  $ Col2 : num  11 12 11 8 12 16 18 12 12 17 ...
    ##  $ Col3 : num  2 22 2 44 7 9 15 5 26 22 ...
    ##  $ Col4 : num  0 2 0 28 2 8 7 3 4 21 ...
    ##  $ Col5 : num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col6 : num  1 1 0 0 0 0 0 1 1 0 ...
    ##  $ Col7 : num  0 1 0 1 1 1 0 0 0 1 ...
    ##  $ Col8 : num  2 3 2 0 1 0 0 0 2 0 ...
    ##  $ Col9 : num  1 1 0 1 0 1 1 1 1 1 ...
    ##  $ Col10: num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col11: num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col12: num  1 1 1 1 1 1 1 1 1 1 ...
    ##  $ Col13: num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col14: num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col15: num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col16: num  0 0 1 0 0 0 1 0 1 0 ...
    ##  $ Col17: num  0 1 0 0 0 0 0 0 0 0 ...
    ##  $ Col18: num  0 0 0 0 0 1 0 0 0 0 ...
    ##  $ Col19: num  0 0 0 0 0 1 1 1 1 1 ...
    ##  $ Col20: num  0 0 0 1 0 0 0 0 0 0 ...
    ##  $ Col21: num  0 1 0 0 0 0 0 0 0 0 ...
    ##  $ Col22: num  1.13 1.18 1.1 1.79 1.67 ...
    ##  $ Col23: num  4 484 4 1936 49 ...
    ##  $ Col24: num  0 4 0 784 4 64 49 9 16 441 ...

    ## 'data.frame':    141 obs. of  29 variables:
    ##  $ Col1 : num  21 21 20 19 20 20 22 22 22 19 ...
    ##  $ Col2 : num  0 0 0 1 0 0 0 0 0 1 ...
    ##  $ Col3 : num  0 0 1 0 1 0 0 0 0 0 ...
    ##  $ Col4 : num  1 1 0 0 0 1 0 0 0 0 ...
    ##  $ Col5 : num  0 0 0 0 0 0 1 1 1 0 ...
    ##  $ Col6 : num  0 0 0 1 0 1 0 0 0 0 ...
    ##  $ Col7 : num  0 0 0 1 0 1 0 0 0 0 ...
    ##  $ Col8 : num  1 1 1 1 1 1 1 0 0 1 ...
    ##  $ Col9 : num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col10: num  3 3.4 3 3.5 3.6 3 2.7 2.7 2.7 3.8 ...
    ##  $ Col11: num  3 3.2 3.6 3.5 3.9 3.4 3.5 3 3 4 ...
    ##  $ Col12: num  21 24 26 27 28 25 25 22 21 27 ...
    ##  $ Col13: num  0 0 1 1 0 0 0 1 1 1 ...
    ##  $ Col14: num  1 1 0 0 1 0 0 0 0 0 ...
    ##  $ Col15: num  1 1 0 0 0 0 0 1 1 0 ...
    ##  $ Col16: num  0 0 0 0 1 0 1 0 0 0 ...
    ##  $ Col17: num  0 0 1 1 0 1 0 0 0 1 ...
    ##  $ Col18: num  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ Col19: num  0 0 0 0 0 0 0 1 0 1 ...
    ##  $ Col20: num  0 0 0 0 0 0 1 0 0 0 ...
    ##  $ Col21: num  1 1 1 0 1 1 1 0 1 0 ...
    ##  $ Col22: num  1 0 1 1 1 1 1 1 1 1 ...
    ##  $ Col23: num  0 1 0 0 1 0 0 1 1 0 ...
    ##  $ Col24: num  0 1 1 0 0 0 1 0 1 1 ...
    ##  $ Col25: num  2 0 0 0 0 0 0 3 2 0.5 ...
    ##  $ Col26: num  1 1 1 0 1.5 0 2 3 2.5 0.75 ...
    ##  $ Col27: num  1 1 1 0 1 0 1 1 1 1 ...
    ##  $ Col28: num  0 1 1 0 1 1 0 1 1 0 ...
    ##  $ Col29: num  0 1 1 0 0 0 1 1 1 1 ...

    ## 'data.frame':    15 obs. of  4 variables:
    ##  $ Year: int  1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 ...
    ##  $ Y   : num  16608 17511 20171 20933 20406 ...
    ##  $ X2  : num  276 274 270 267 268 ...
    ##  $ X3  : num  17804 18097 18272 19167 19648 ...

    ## 'data.frame':    31 obs. of  6 variables:
    ##  $ COUNTRY: Factor w/ 31 levels "Argentina","Australia",..: 31 1 2 3 4 5 6 7 8 9 ...
    ##  $ BMACLC : num  2.54 2.5 3 3.6 1.99 ...
    ##  $ BMAC.  : num  2.54 2.5 1.52 1.64 2.85 2.14 2.1 1.2 1.43 2.93 ...
    ##  $ EXCH   : num  -99999 1 1.98 2.19 1.43 ...
    ##  $ PPP    : num  -99999 0.98 1.18 1.42 1.28 ...
    ##  $ LOCALC : int  -99999 -40 -35 -31 12 -16 -17 -53 -44 15 ...

    ## 'data.frame':    34 obs. of  4 variables:
    ##  $ Country   : Factor w/ 34 levels "Argentina","Australia",..: 1 2 3 4 5 6 7 8 9 10 ...
    ##  $ Cellphone : num  17.8 72 79.3 26.4 46.6 ...
    ##  $ PCs       : num  8.2 60.18 31.81 7.48 5.19 ...
    ##  $ Pcapincome: int  11410 28780 28920 7510 7400 30040 4980 6410 15600 3940 ...

    ## 'data.frame':    51 obs. of  5 variables:
    ##  $ State   : Factor w/ 51 levels "Alabama","Alaska",..: 7 14 15 16 17 20 22 23 24 26 ...
    ##  $ Salary  : int  60822 58246 47831 43130 43334 41596 58624 54895 49634 41839 ...
    ##  $ Spending: int  12436 9275 8935 7807 8373 11285 12596 9880 9675 7840 ...
    ##  $ D2      : int  1 1 1 1 1 1 1 1 1 1 ...
    ##  $ D3      : int  0 0 0 0 0 0 0 0 0 0 ...

    ## 'data.frame':    97 obs. of  1 variable:
    ##  $ IPC.Mes.Year: Factor w/ 97 levels "100,ENE,05","100.18,FEB,05",..: 1 2 3 11 12 9 8 5 4 6 ...

    ## 'data.frame':    135 obs. of  38 variables:
    ##  $ Year                                                : int  2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...
    ##  $ Mes                                                 : Factor w/ 13 levels "","Abr","Ago",..: 5 5 6 6 9 9 2 2 10 10 ...
    ##  $ mesnum                                              : int  1 1 2 2 3 3 4 4 5 5 ...
    ##  $ Tipo                                                : Factor w/ 5 levels "Extrj","Nac",..: 2 1 2 1 2 1 2 1 2 1 ...
    ##  $ PARQUE_NACIONAL_CAJAS                               : int  2311 804 2590 884 2873 992 2669 640 1988 651 ...
    ##  $ PARQUE_NACIONAL_COTOPAXI                            : int  4925 3628 4761 2561 2279 2611 3739 2570 3379 2985 ...
    ##  $ PARQUE_NACIONAL_GALAPAGOS                           : int  3863 9231 4795 8278 5502 9687 4816 9876 4857 8593 ...
    ##  $ PARQUE_NACIONAL_LLANGANATES                         : int  2 0 83 0 18 0 0 0 0 0 ...
    ##  $ PARQUE_NACIONAL_MACHALILLA                          : int  1531 761 4345 500 1130 467 1932 434 1123 448 ...
    ##  $ PARQUE_NACIONAL_PODOCARPUS                          : int  26 107 33 25 60 75 342 39 268 46 ...
    ##  $ PARQUE_NACIONAL_SANGAY                              : int  84 25 141 29 108 30 182 14 124 7 ...
    ##  $ PARQUE_NACIONAL_SUMACO                              : int  10 0 14 1 7 0 4 0 0 1 ...
    ##  $ PARQUE_NACIONAL_YASUNI                              : int  26 3013 1 11 0 72 0 154 0 100 ...
    ##  $ RESERVA_BIOLOGICA_LIMONCOCHA                        : int  24 40 25 28 92 83 34 35 64 0 ...
    ##  $ RESERVA_BIOLOGICA_MARINA_GALAPAGOS                  : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ RESERVA_ECOLOGICA_ANTISANA                          : int  0 20 105 8 171 0 69 0 23 52 ...
    ##  $ RESERVA_ECOLOGICA_COFAN_BERMEJO                     : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ RESERVA_ECOLOGICA_ARENILLAS                         : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ RESERVA_ECOLOGICA_EL_ANGEL                          : int  79 6 268 8 145 36 133 11 135 34 ...
    ##  $ RESERVA_ECOL._CAYAMBE_COCA                          : int  314 55 458 11 100 23 644 71 540 43 ...
    ##  $ RESERVA_ECOL._CAYAPAS_MATAJE                        : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ RESERVA_ECOL._COTACACHI_CAYAPAS                     : int  5979 1890 7704 1694 8517 1935 8354 1895 8009 1798 ...
    ##  $ RESERVA_ECOLOGICA_LOS_ILINIZAS                      : int  7 79 78 32 53 21 14 13 33 23 ...
    ##  $ RESERVA_ECOL._MACHE_CHINDUL                         : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ RESERVA_ECOL._MANGLARES_CHURUTE                     : int  20 11 49 5 37 17 42 8 0 12 ...
    ##  $ RESERVA_GEOBOTANICA_PULULAHUA                       : int  445 40 464 43 302 96 920 46 846 30 ...
    ##  $ RESERVA_FAUNISTICA_CHIMBORAZO                       : int  1583 1061 626 829 230 442 462 417 385 342 ...
    ##  $ RESERVA_FAUNISTICA_CUYABENO                         : int  224 293 181 236 86 242 196 311 146 357 ...
    ##  $ RESERVA_FAUNISTICA_MANGLARES_SALADO                 : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ REFUGIO_DE_VIDA_SILVESTRE_ISLA_CORAZON_Y_FRAGATAS   : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ REFUGIO_DE_VIDA_SILVESTRE_ISLA_SANTA_CLARA          : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ REFUGIO_DE_VIDA_SILVESTRE_LA_CHIQUITA               : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ REFUGIO_DE_VIDA_SILVESTRE_MANGLES_ESTURIO_RIO_MUISNE: int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ REFUGIO_DE_VIDA_SILVESTRE_PASOCHOA                  : int  1146 87 1540 31 647 18 660 32 970 37 ...
    ##  $ AREA_NACIONAL_DE_RECREACION_PARQUE_LAGO             : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ AREA_NACIONAL_RECREACION_BOLICHE                    : int  439 11 825 6 1434 17 1947 15 1380 27 ...
    ##  $ PARQUE_EL_CONDOR                                    : int  0 0 0 0 0 0 0 0 0 0 ...
    ##  $ TOTALMENSUAL                                        : int  23038 21162 29086 15220 23791 16864 27159 16581 24270 15586 ...

    ## 'data.frame':    1567 obs. of  2 variables:
    ##  $ DATE : Factor w/ 1567 levels "01/01/01","01/01/79",..: 260 621 981 1341 110 471 831 1191 115 476 ...
    ##  $ VALUE: num  67.8 67.5 67 66.2 66.2 67.4 67.3 66.5 66.9 68.3 ...

    ## 'data.frame':    94 obs. of  2 variables:
    ##  $ year  : int  1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 ...
    ##  $ precio: num  277 315 315 321 315 ...

    ## 'data.frame':    136 obs. of  1 variable:
    ##  $ caemp: num  83.1 82.8 84.6 85.4 86.2 ...

    ## 'data.frame':    1004 obs. of  3 variables:
    ##  $ V1: Factor w/ 951 levels "0.47383","0.47523",..: 951 747 692 626 657 593 524 512 537 548 ...
    ##  $ V2: Factor w/ 869 levels "1.2365","1.2443",..: 869 638 562 563 564 534 504 487 500 489 ...
    ##  $ V3: Factor w/ 973 levels "0.67296","0.67351",..: 973 554 514 449 520 453 398 427 477 485 ...

Observarás que los archivos SLEEP, HPRICE1, WAGE1, GPA1 y CEOSAL2 no
tienen nombres de las columnas. Los vectores de nombres son:

    nomsleep <- c("age", "black", "case", "clerical" , "construc"  ,"educ","earns74","gdhlth"   
                    ,"inlf", "leis1", "leis2", "leis3", "smsa", "lhrwage", "lothinc", "male",     
                    "marr", "prot", "rlxall", "selfe", "sleep", "slpnaps", "south", "spsepay",  
                    "spwrk75", "totwrk" ,  "union" , "worknrm" , "workscnd", "exper" , "yngkid",
                    "yrsmarr", "hrwage", "agesq") 
    nomprecios=c("price"   ,  "assess"  , 
                     "bdrms"  ,   "lotsize"  ,
                     "sqrft"   ,  "colonial",
                     "lprice"  ,  "lassess" ,
                     "llotsize" , "lsqrft")

    nomwages <- c("wage", "educ", "exper", "tenure", "nonwhite", "female", "married",
                         "numdep", "smsa", "northcen", "south", "west", "construc", "ndurman",
                         "trcommpu", "trade", "services",  "profserv", "profocc", "clerocc",
                         "servocc", "lwage", "expersq", "tenursq")

    nomgpa <- c("age",  "soph",  "junior",    "senior", "senior5",  "male", "campus",   "business", "engineer", "colGPA",   "hsGPA",    "ACT",  "job19",    "job20",    "drive",    "bike", "walk", "voluntr",  "PC",   "greek",    "car",  "siblings", "bgfriend", "clubs",    "skipped",  "alcohol",  "gradMI",   "fathcoll", "mothcoll")

    nomceosal <- c("salary", "age", "college", "grad", "comten", "ceoten", "sales", "profits", 
                     "mktval", "lsalary", "lsales", "lmktval", "comtensq", "ceotensq", "profmarg")

### ... Si llegaste hasta aquí: FELICITACIONES!!!

Referencias
===========

Kross, Sean, Nick Carchedi, Bill Bauer, and Gina Grdina. 2017. *Swirl:
Learn R, in R*. <https://CRAN.R-project.org/package=swirl>.
